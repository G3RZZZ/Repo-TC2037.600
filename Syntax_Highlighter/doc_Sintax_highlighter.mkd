# Documentation for Syntax Highlighter

##### by Mateo Herrera Lavalle A01751912, Gerardo GutiÃ©rrez Paniagua A01029422

---

### How to run the program:

Elixir has to be installed in some form or manner, this because the command needed to run the program originates from the elixir terminal instance. This can be easily achieved through the official elixir install documentation which can be found [here](https://elixir-lang.org/install.html).

Once installed, in order to run the code, the elixir interactive terminal must be opened. To do this first move to the Syntax_Highlighter directory inside your terminal and then execute the iex command (or iex.bat if you are on Windows PowerShell, where iex is a PowerShell command) followed by the the elixir file that contains the code. This should look like the following:

    iex SyntaxHighlight.exs

or

    iex SyntaxHighlightV2.exs

or

    iex SyntaxHighlightV3.exs

Once the elixir execution mode is active, an example of the command that will run the program is:

    Highlighter.syntaxHighlight("Test_files/example_0.json")

Where Highlighter is the name of the module, syntaxHighlight is the function that reads the file being highlighted. The argument for said function is the address of the file, in this case its under the Test_files folder by the name of example_0.json. 

If the time of execution is to be measured, the module changes, an example is:

    Benchmark.measure(fn -> Highlighter.syntaxHighlight("Test_files/example_0.json") end)

In the example, Benchmark is the module used, and measure the name of the function that will time the given code. The argument is signaling the function that will be measured using (fn -> + <*the name of the module.name of the function* + ***the arguments for the function***> end)

---

### Reflection and analysis:

## SyntaxHighlightV3.exs

The best json syntax highlighter performance wise. This version uses the same identify function as V2, but instead of applying it to a stringified file as a whole, it applies it to every line in the file individually.Because of this, the temporal complexity of the code dropped a lot more. This also solved teh problem of having to replace the newline token.

This solution almost immediate, and it does not scale drastically with larger files. In fact, the temporal complexity of this solution appears to be of n. V2 does not scale as well with larger files, so it is possible to classify this as the most efficient version yet.

## SyntaxHighlightV2.exs

The new and improved json syntax highlighter. Unlike its predecessor this version of the program does not used Regex.replace as its main functionality. Because of this, the temporal complexity of the code dropped drastically. This also solved various problems within the regex expressions needed to achieve the correct token identification inside the file since the tokens where removed when identified, thus avoiding re-identification inside the same line.

This solution is relatively immediate, reaching a lowest time of 0.002 seconds, an an average run time of 0.01 seconds, marginally better than the previous version. The execution time will depend on the size off the file. The complexity of this solution can be estimated to be n^2. This is better than the previous identifier, since the last one was almost n^3.

## SyntaxHighlight.exs

Looking back at the proposed solution, the algorithms used are a smart and simple way to achieve the objective of the program. Using a recursive function the code can identify each element that we are looking for in a json file and replace it on an html file. For this, Regex is a great tool and technology that is a vital part to the correct functioning of the highlighter. This solution, however, is not an optimal one in the long run. This is so since, for each of the Regex expressions used in the function, the programmer needs to consider every single possible manner in which the tokens might interact. For example, a json file might have a number inside a string. This case needs to be considered when developing the number identifier Regex expression to assure that it will not be identified inside of a string. Even so, the solution presented correctly identifies the tokens present in this project's test json files.

The solution is relatively immediate, reaching an average run time of 0.26 seconds, which leads us to think that logically, the program is well structured. The execution time will depend on the size of the file and the iterations that it will make on each line of said file.

The complexity is estimated at n^2, almost n^3, because the algorithm iterates several times on each time for every line of a json file. With the complexity in mind, the time that it takes for the program to run is accurate as the time fluctuates according to the size of the file and the lines in it. It makes sense that a small file is highlighted almost immediately while a larger json with several lines of data takes more time to complete the highlighted html file. 

## Ethical responsibility

Regarding the ethical aspect of the development of this program, we believe that it is completely ethical when used for its purpose, and that it could actually be beneficial when looking for syntax errors on json files. However, regular expressions (Regex) can be misused, leading to practices that are not as common among developers. 

Regex has the potential to be efficient when identifying strings, reducing the amount of code needed for a process. But as mentioned before, the overuse of regex can turn into complex algorithms and difficult debugging. A balance in the use of this technology is possibly the correct way to go, using small to medium expressions, leaving regex with triple character digits well of the scope of ideal use. 

